#include "stdafx.h"
#include "Vista.h"
#include "Common.h"

#ifdef _DEBUG
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

typedef struct _TOKEN_ELEVATION {
  DWORD TokenIsElevated;
}TOKEN_ELEVATION;

#define TokenElevation (_TOKEN_INFORMATION_CLASS)20



bool CVista::Elevate()
{
	_log.WriteInfo("Elevate()");

	CStringW path = CCommon::GetModuleFileNameW(0);
			
	SHELLEXECUTEINFOW sei;
	sei.cbSize = sizeof(sei);
	sei.fMask = 0;
	sei.hwnd = 0;
	sei.lpVerb = L"runas";
	sei.lpFile = (LPCWSTR)path;
	sei.lpParameters = L"-elevated";
	sei.lpDirectory = NULL;
	sei.nShow = SW_SHOW;
	sei.hInstApp = NULL;	

	if (::ShellExecuteExW(&sei)==0) {
		DWORD dwError = ::GetLastError();
		if (dwError==ERROR_CANCELLED) return false;
		throw RLException("Error %d in Elevate()", ::GetLastError());
	}

	return true;

	//HINSTANCE h = ::ShellExecuteA(0, "runas", "calc.exe", 0, 0, SW_SHOWNORMAL);
	//DWORD dwError = ::GetLastError();
	//_log.WriteError("ShellExecuteA() %d %d", (int)h, (int)dwError);
}


bool CVista::IsElevated()
{	
	HANDLE hToken = NULL;
	if (::OpenProcessToken(::GetCurrentProcess(), TOKEN_QUERY, &hToken)==0)
		throw RLException("error %d in IsElevated()#1", ::GetLastError());
	
	TOKEN_ELEVATION Elevation;
	DWORD cbSize = sizeof(TOKEN_ELEVATION);	
	if (::GetTokenInformation(hToken, TokenElevation, &Elevation, sizeof(Elevation), &cbSize)==0) {
		DWORD dwError = ::GetLastError();
		::CloseHandle(hToken);
		throw RLException("error %d in IsElevated()#2", dwError);
	}
	::CloseHandle(hToken);

	return Elevation.TokenIsElevated ? true : false;
}

BOOL CVista::SetForegroundWindow(HWND hWnd)
{
	HWND hwndForeground = ::GetForegroundWindow();
	DWORD dwForegroundWindowThread = ::GetWindowThreadProcessId(hwndForeground, NULL);
	DWORD dwBringToForegroundThread = ::GetWindowThreadProcessId(hWnd, NULL);

	//http://www.ddj.com/windows/184405755
	//Use of AttachThreadInput to join two threads together 
	//temporarily in order for the messages generated by SetForegroundWindow
	//to be processed properly by the target window. 
	//The first call does the join (by passing in TRUE as the third parameter)
	//and the second call reverses the join.

	//join Foreground thread and BringToForegroundThread
	if(!::AttachThreadInput(dwForegroundWindowThread, dwBringToForegroundThread, TRUE)) {
		_log.WriteError("SetForegroundWindow()#1 Error %d", ::GetLastError());
		return FALSE;
	}

	if(!::SetForegroundWindow(hWnd)) {
		_log.WriteError("SetForegroundWindow()#2 Error %d", ::GetLastError());
		return FALSE;
	}

	//reverse join Foreground thread and BringToForegroundThread
	if(!::AttachThreadInput(dwForegroundWindowThread, dwBringToForegroundThread, FALSE)) {
		_log.WriteError("SetForegroundWindow()#3 Error %d", ::GetLastError());
		return FALSE;
	}

	HWND hwndPrevActive = ::SetActiveWindow(hWnd);
	if(!hwndPrevActive) {
		_log.WriteError("SetForegroundWindow()#4 Error %d", ::GetLastError());
		return FALSE;
	}
	
	return TRUE;
}

